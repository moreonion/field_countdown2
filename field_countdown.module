<?php

/**
 * @file
 * Countdown timer field module allows you to create countdown timer
 * field to count the days, hours, minutes, and seconds until a specified
 * event.
 */

/**
 * Implements hook_field_info().
 */
function field_countdown_field_info() {
  $granularity = array('year', 'month', 'day', 'hour', 'minute');
  $settings = array(
    'settings' => array(
      'todate' => '',
      'granularity' => drupal_map_assoc($granularity),
      'tz_handling' => 'site',
      'timezone_db' => 'UTC',
			'visibility' => 1,
    ),
    'instance_settings' => array(
      'default_value' => 'now',
      'default_value_code' => '',
      'default_value2' => 'same',
      'default_value_code2' => '',
    ),
    // Integrate with the Entity Metadata module.
    'property_type' => 'date',
    'property_callbacks' => array('date_entity_metadata_property_info_alter'),
  );

	$return = array(
		'field_countdown' => array(
			'label' => t('Countdown Timer Field'),
			'description' => t('Countdown Timer Field.'),
			'default_widget' => 'date_widget',
			'default_formatter' => 'field_countdown_default',
		) + $settings
	); 

	return $return;
}

/**
 * Implements hook_field_load().
 */
function field_countdown_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
	module_load_include('inc', 'date', 'date.field');
	date_field_load($entity_type, $entities, $field, $instances, $langcode, $items, $age);
}

/* function field_countdown_field_widget_info() { */
/* 	module_load_include('inc', 'date', 'date.field.inc'); */
/* 	$info = date_field_widget_info(); */
/* 	$info['date_text']['settings'] += array('visibility' => 1); */
/* 	$info['date_text']['field types'] = array('field_countdown'); */
/* 	$info['date_text']['behaviors']['multiple values'] = FIELD_BEHAVIOR_NONE; */

/* 	$info['date_select']['settings'] += array('visibility' => 1); */
/* 	$info['date_select']['field types'] = array('field_countdown'); */
/* 	$info['date_select']['behaviors']['multiple values'] = FIELD_BEHAVIOR_NONE; */

/* 	if(module_exists('date_popup')) { */
/* 		$info['date_popup']['settings'] += array('visibility' => 1); */
/* 		$info['date_popup']['field types'] = array('field_countdown'); */
/* 		$info['date_popup']['behaviors']['multiple values'] = FIELD_BEHAVIOR_NONE; */
/* 	} */
/* 	dpm($info); */

/* 	return $info; */
/* } */

/**
 * Implements hook_field_widget_info_alter().
 */
function date_field_widget_info_alter(&$info) {
	$info['date_text']['field types'][] = 'field_countdown';

	$info['date_select']['field types'][] = 'field_countdown';

	if(module_exists('date_popup')) {
		$info['date_popup']['field types'][] = 'field_countdown';
	}
}

/**
 * Implements hook_field_widget_form_alter().
 */
function date_field_widget_form_alter(&$element, &$form_state, $context) {
  $field = $context['field'];
  $instance = $context['instance'];
  $items = $context['items'];
  $delta = $context['delta'];

  if ($field['type'] === 'field_countdown') {
		$default = isset($items[$delta]['visibility']) ? $items[$delta]['visibility'] : $field['settings']['visibility'];
		$element['visibility'] = array(
			'#type' => 'checkbox',
			'#title' => t('Visible'),
			'#default_value' => $default
		);
		$element['#element_validate'] = array('field_countdown_validate');
  }
}

function field_countdown_type_format($type) {
	module_load_include('module', 'date_api', 'date_api');

	switch($type) {
	case 'field_countdown':
		return DATE_FORMAT_UNIX;
	default:
		date_type_format($type);
	}
}

/**
 * Validate and update a field_countdown element.
 * This is a bad solution, we just needed to change 2 LOCs.
 *
 * Don't try this if there were errors before reaching this point.
 */
function field_countdown_validate($element, &$form_state) {
	module_load_include('inc', 'date', 'date_elements');
  // Disabled and hidden elements won't have any input and don't need validation,
  // we just need to re-save the original values, from before they were processed into
  // widget arrays and timezone-adjusted.
  if (date_hidden_element($element) || !empty($element['#disabled'])) {
    form_set_value($element, $element['#date_items'], $form_state);
    return;
  }

  $field_name = $element['#field_name'];
  $delta = $element['#delta'];
  $langcode = $element['#language'];

  // Related issue: https://drupal.org/node/2279831.
  if (!is_array($element['#field_parents'])) {
    $element['#field_parents'] = array();
  }
  $form_values = drupal_array_get_nested_value($form_state['values'], $element['#field_parents']);
  $form_input = drupal_array_get_nested_value($form_state['input'], $element['#field_parents']);

  // Programmatically calling drupal_submit_form() does not always add the date
  // combo to $form_state['input'].
  if (empty($form_input[$field_name]) && !empty($form_values[$field_name])) {
    form_set_value($element, $element['#date_items'], $form_state);
    return;
  }
  // If the whole field is empty and that's OK, stop now.
  if (empty($form_input[$field_name]) && !$element['#required']) {
    return;
  }

  $item = drupal_array_get_nested_value($form_state['values'], $element['#parents']);
  $posted = drupal_array_get_nested_value($form_state['input'], $element['#parents']);

  $field = field_widget_field($element, $form_state);
  $instance = field_widget_instance($element, $form_state);

  $context = array(
    'field' => $field,
    'instance' => $instance,
    'item' => $item,
  );

  drupal_alter('date_combo_pre_validate', $element, $form_state, $context);

  $from_field = 'value';
  $to_field = 'value2';
  $tz_field = 'timezone';
  $offset_field = 'offset';
  $offset_field2 = 'offset2';

  // Check for empty 'Start date', which could either be an empty
  // value or an array of empty values, depending on the widget.
  $empty = TRUE;
  if (!empty($item[$from_field])) {
    if (!is_array($item[$from_field])) {
      $empty = FALSE;
    }
    else {
      foreach ($item[$from_field] as $key => $value) {
        if (!empty($value)) {
          $empty = FALSE;
          break;
        }
      }
    }
  }

  // An 'End' date without a 'Start' date is a validation error.
  if ($empty && !empty($item[$to_field])) {
    if (!is_array($item[$to_field])) {
      form_error($element, t("A 'Start date' date is required if an 'end date' is supplied for field %field #%delta.", array('%delta' => $field['cardinality'] ? intval($delta + 1) : '', '%field' => $instance['label'])));
      $empty = FALSE;
    }
    else {
      foreach ($item[$to_field] as $key => $value) {
        if (!empty($value)) {
          form_error($element, t("A 'Start date' date is required if an 'End date' is supplied for field %field #%delta.", array('%delta' => $field['cardinality'] ? intval($delta + 1) : '', '%field' => $instance['label'])));
          $empty = FALSE;
          break;
        }
      }
    }
  }

  // If the user chose the option to not show the end date, just swap in the
  // start date as that value so the start and end dates are the same.
  if ($field['settings']['todate'] == 'optional' && empty($item['show_todate'])) {
    $item[$to_field] = $item[$from_field];
    $posted[$to_field] = $posted[$from_field];
  }

  if ($empty) {
    $item = date_element_empty($element, $form_state);
    if (!$element['#required']) {
      return;
    }
  }
  else {
    $timezone = !empty($item[$tz_field]) ? $item[$tz_field] : $element['#date_timezone'];
    $timezone_db = date_get_timezone_db($field['settings']['tz_handling']);
    $element[$from_field]['#date_timezone'] = $timezone;
    $from_date = date_input_date($field, $instance, $element[$from_field], $posted[$from_field]);

    if (!empty($field['settings']['todate'])) {
      $element[$to_field]['#date_timezone'] = $timezone;
      $to_date = date_input_date($field, $instance, $element[$to_field], $posted[$to_field]);
    }
    else {
      $to_date = $from_date;
    }

    // Neither the start date nor the end date should be empty at this point
    // unless they held values that couldn't be evaluated.

    if (!$instance['required'] && (!date_is_date($from_date) || !date_is_date($to_date))) {
      $item = date_element_empty($element, $form_state);
      $errors[] = t('The dates are invalid.');
    }
    elseif (!empty($field['settings']['todate']) && $from_date > $to_date) {
      form_set_value($element[$to_field], $to_date, $form_state);
      $errors[] = t('The End date must be greater than the Start date.');
    }
    else {
      // Convert input dates back to their UTC values and re-format to ISO
      // or UNIX instead of the DATETIME format used in element processing.
      $item[$tz_field] = $timezone;

      // Update the context for changes in the $item, and allow other modules to
      // alter the computed local dates.
      $context['item'] = $item;
      // We can only pass two additional values to drupal_alter, so $element
      // needs to be included in $context.
      $context['element'] = $element;
      drupal_alter('date_combo_validate_date_start', $from_date, $form_state, $context);
      drupal_alter('date_combo_validate_date_end', $to_date, $form_state, $context);

      $item[$offset_field] = date_offset_get($from_date);

      $test_from = date_format($from_date, 'r');
      $test_to = date_format($to_date, 'r');

      $item[$offset_field2] = date_offset_get($to_date);
      date_timezone_set($from_date, timezone_open($timezone_db));
      date_timezone_set($to_date, timezone_open($timezone_db));
      $item[$from_field] = date_format($from_date, field_countdown_type_format($field['type']));
      $item[$to_field] = date_format($to_date, field_countdown_type_format($field['type']));
      if (isset($form_values[$field_name]['rrule'])) {
        $item['rrule'] = $form_values[$field['field_name']]['rrule'];
      }

      // If the db timezone is not the same as the display timezone
      // and we are using a date with time granularity,
      // test a roundtrip back to the original timezone to catch
      // invalid dates, like 2AM on the day that spring daylight savings
      // time begins in the US.
      $granularity = date_format_order($element[$from_field]['#date_format']);
      if ($timezone != $timezone_db && date_has_time($granularity)) {
        date_timezone_set($from_date, timezone_open($timezone));
        date_timezone_set($to_date, timezone_open($timezone));

        if ($test_from != date_format($from_date, 'r')) {
          $errors[] = t('The Start date is invalid.');
        }
        if ($test_to != date_format($to_date, 'r')) {
          $errors[] = t('The End date is invalid.');
        }
      }
      if (empty($errors)) {
        form_set_value($element, $item, $form_state);
      }
    }
  }
  // Don't show further errors if errors are already flagged
  // because otherwise we'll show errors on the nested elements
  // more than once.
  if (!form_get_errors() && !empty($errors)) {
    if ($field['cardinality']) {
      form_error($element, t('There are errors in @field_name value #@delta:', array('@field_name' => $instance['label'], '@delta' => $delta + 1)) . theme('item_list', array('items' => $errors)));
    }
    else {
      form_error($element, t('There are errors in @field_name:', array('@field_name' => $instance['label'])) . theme('item_list', array('items' => $errors)));
    }
  }
}

/**
 * Implements hook_field_settings_form().
 */
function field_countdown_field_settings_form($field, $instance, $has_data) {
	module_load_include('inc', 'date', 'date.field');
	return date_field_settings_form($field, $instance, $has_data);
}

/**
 * Implements hook_field_is_empty().
 */
function field_countdown_field_is_empty($item, $field) {
	module_load_include('inc', 'date', 'date.field');
	date_field_is_empty($item, $field);
}

/**
 * Implements hook_field_formatter_info().
 */
function field_countdown_field_formatter_info() {
  return array(
    'field_countdown_default' => array(
      'label' => t('jQuery Countdown Timer without text timer'),
      'field types' => array('date', 'datetime', 'datestamp'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      'settings' => array(
        'font_size' => '48',
        'font_size_note' => '22'),
    ),
    'field_countdown_with_text_timer' => array(
      'label' => t('jQuery Countdown Timer with text timer'),
      'field types' => array('date', 'datetime', 'datestamp'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      'settings' => array(
        'font_size' => '48',
        'font_size_note' => '22'),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function field_countdown_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  if($display['type'] === 'field_countdown_default' ||
     $display['type'] === 'field_countdown_with_text_timer') {

    $element['font_size'] = array(
      '#title' => t('Font size of countdown'),
      '#type' => 'textfield',
      '#default_value' => $settings['font_size'],
      '#element_validate' =>
        array('element_validate_integer_positive'),
      '#required' => TRUE
    );

    $element['font_size_note'] = array(
      '#title' => t('Font size of text'),
      '#type' => 'textfield',
      '#default_value' => $settings['font_size_note'],
      '#element_validate' =>
        array('element_validate_integer_positive'),
      '#required' => TRUE
    );
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function field_countdown_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = '';

  if($display['type'] === 'field_countdown_default' ||
     $display['type'] === 'field_countdown_with_text_timer') {

    $summary = t('Font size of countdown is @size px. Font size of text is @note px.',
     array('@size' => $settings['font_size'], '@note' => $settings['font_size_note']));
  }

  return $summary;
}

/**
 * Implements hook_field_formatter_view().
 */
function field_countdown_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $countdown_field_id = drupal_html_id("countdown-timer-countdown");
  $font_size = $display['settings']['font_size'];
  $font_size_note = $display['settings']['font_size_note'];

  switch ($display['type']) {
    case 'field_countdown_default':
      foreach ($items as $delta => $item) {
				if($item['visibility'] === '1') {
					$date = new DateObject($item['value'], new DateTimeZone('UTC'));
					$endstamp = $date->getTimestamp();

					$element[$delta]['#markup'] = _field_countdown_display_timer(
						check_plain($endstamp), $font_size, $font_size_note, $countdown_field_id, FALSE
					);
				}
      }
      break;

    case 'field_countdown_with_text_timer':
      foreach ($items as $delta => $item) {
				if($item['visibility'] === '1') {
					$date = new DateObject($item['value'], new DateTimeZone('UTC'));
					$endstamp = $date->getTimestamp();

					$element[$delta]['#markup'] = _field_countdown_display_timer(
							check_plain($endstamp), $font_size, $font_size_note, $countdown_field_id, TRUE
					);
				}
      }
      break;
  }

  return $element;
}

/**
 * Creates the jquery countdown timer.
 */
function _field_countdown_display_timer($time, $font_size, $font_size_note, $countdown_field_id, $text_timer = FALSE) {
  $path = libraries_get_path('jquery-countdown');
  drupal_add_js($path . '/assets/countdown/jquery.countdown.js', array(
    'type' => 'file', 'scope' => 'footer',
      )
  );
  $suffix = str_replace(array('.', ' '), array('-', '-'), microtime());
  $settings = array(
    $countdown_field_id => array(
      'countdown-settings-time' => $time,
    ),
  );
  drupal_add_js(array('field_countdown' => $settings), 'setting');
  drupal_add_js(drupal_get_path('module', 'field_countdown') . '/field_countdown.js', array(
    'scope' => 'footer', 'weight' => 5,
  ));

  drupal_add_css($path . '/assets/countdown/jquery.countdown.css');
  drupal_add_css(
    '.countdownHolder {font-size: ' . $font_size . 'px}', 'inline'
  );
  drupal_add_css(
    '.countdown-timer-note { font-size: ' . $font_size_note . 'px }', 'inline'
  );

  $content = theme(
    'field_countdown_timer',
    array(
      'id' => $countdown_field_id,
      'text_timer' => $text_timer,
    )
  );

  return $content;
}

/**
 * Implements hook_theme().
 */
function field_countdown_theme() {
  return array(
    'field_countdown_timer' => array(
      'variables' => array(),
    ),
  );
}

/**
 * Returns HTML for the timer container.
 */
function theme_field_countdown_timer($variables) {
  $note_id = drupal_html_id("countdown-timer-note");

  $output = "<div class='countdown-timer'>";
  $output .= "<div id='" . $variables['id'] . "' class='countdown-timer-countdown'></div>";
  if ($variables['text_timer']) {
    $output .= "<div id='" . $note_id . "' class='countdown-timer-note'></div>";
  }
  $output .= "</div>";

  return $output;
}
